install.packages("spatstat",repos = "http://cran.r-project.org")
library(spatstat)
?spatstat
rm(list=ls())
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
class(jp)
summary(jp)
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
# 1. Load the R Packages
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
class(jp)
summary(jp)
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
# 2.1 First-order effect
## kernel density
?density.ppp
jp.Z.05 = density.ppp(jp, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.05"))
plot(jp.Z.05, main = tl.05)
plot(jp.Z.05, main="Kernel Estimation of JP: sigma = 0.05")
points(jp,pch="+",col="6")
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
points(jp,pch="+",col="6")
# 1. Load the R Packages
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
class(jp)
summary(jp)
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
# 2.1 First-order effect
## kernel density (sigma = 0.05)
?density.ppp
jp.Z.05 = density.ppp(jp, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.05"))
plot(jp.Z.05, main = tl.05)
plot(jp.Z.05, main="Kernel Estimation of JP: sigma = 0.05")
points(jp,pch="+",col="6")
## kernel density (sigma = 0.1)
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
points(jp,pch="+",col="6")
# 2.2 Second-order effect
## event-to-nearest-event distances
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates",
xlab="r", ylab="G(r)")
jp.ghat
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates",
xlim=c(0,g.max), xlab="r", ylab="G(r)")
jp.ghat
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
points(jp,pch="+",col="6")
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
# 1. Load the R Packages
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
class(jp)
summary(jp)
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
# 2.1 First-order effect
## kernel density (sigma = 0.05)
?density.ppp
jp.Z.05 = density.ppp(jp, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.05"))
plot(jp.Z.05, main = tl.05)
plot(jp.Z.05, main="Kernel Estimation of JP: sigma = 0.05")
points(jp,pch="+",col="6")
## kernel density (sigma = 0.1)
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
points(jp,pch="+",col="6")
# 2.2 Second-order effect
## event-to-nearest-event distances
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates",
xlim=c(0,g.max), xlab="r", ylab="G(r)")
## point-to-nearest-event distances
jp.fhat = Fest(jp)
f.max = max(jp.fhat$r)
plot(jp.fhat, cbind(rs,theo)~r, main="F Estimates",
xlab="r", ylab="F(r)")
# 1. Load the R Packages
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
class(jp)
summary(jp)
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
# 2.1 First-order effect
## kernel density (sigma = 0.05)
?density.ppp
jp.Z.05 = density.ppp(jp, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.05"))
plot(jp.Z.05, main = tl.05)
plot(jp.Z.05, main="Kernel Estimation of JP: sigma = 0.05")
points(jp,pch="+",col="6")
## kernel density (sigma = 0.1)
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
points(jp,pch="+",col="6")
# 2.2 Second-order effect
## event-to-nearest-event distances
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates",
xlim=c(0,g.max), xlab="r", ylab="G(r)")
## point-to-nearest-event distances
jp.fhat = Fest(jp)
f.max = max(jp.fhat$r)
plot(jp.fhat, cbind(rs,theo)~r, main="F Estimates",
xlab="r", ylab="F(r)")
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates",
xlim=c(0,g.max), xlab="r", ylab="G(r)")
g.max = max(jp.ghat$r)
plot(jp.ghat,cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
plot(jp.fhat, cbind(rs,theo)~r, main="F Estimates",
xlab="r", ylab="F(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", ylim=c(0,g.max), xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r)
library(spatstat)
?spatstat
rm(list=ls())
data(japanesepines)
jp = japanesepines
# 2.2 Second-order effect
## event-to-nearest-event distances
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlab="r", ylab="G(r)")
plot(jp,axes=T,main=" 65 Japanese black pine saplings")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlab="r", ylab="G(r)", axes=TRUE)
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
jp.ghat = Gest(jp)
g.max = max(jp.ghat$r)
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlim=c(0,g.max), xlab="r", ylab="G(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates", xlab="r", ylab="G(r)")
jp.fhat = Fest(jp)
f.max = max(jp.fhat$r)
plot(jp.fhat, cbind(rs,theo)~r, main="F Estimates",
xlab="r", ylab="F(r)")
plot(jp.ghat, cbind(rs,theo)~r, main="G Estimates",
xlab="r", ylab="G(r)")
## K function
?Kest
jp.khat = Kest(jp)
plot(jp.khat, cbind(border, theo)~r, main="K function for JP data")
jp.khat = Kest(jp)
plot(jp.khat, cbind(border, theo)~r, main="K function for JP data")
## L function
plot(jp.khat, sqrt(border/pi)-r ~ r, ylab="L(r)",
main="L function for JP")
abline(h=0, lty=2, col="red")
r1.ghat=Gest(r1)
r1.ghat$rs
par(mfrow=c(1,2))
plot(r1.ghat)
?runifpoint
N = 65 # number of points to generate
r1 = runifpoint(N) #Generate N uniform random points
par(mar=c(0,0,0,0)) # set plot margin
plot(r1,pch="+",main="65 points under CSR")
# 3.2 Testing CSR using nearest neighbor distances and Monte Carlo simulation
r1.ghat=Gest(r1)
r1.ghat$rs
par(mfrow=c(1,2))
plot(r1.ghat)
plot(r1.ghat)
plot(r1.ghat)
# 3. Hypothesis testing of spatial point patterns
# 3.1 Simulating CSR
?runifpoint
N = 65 # number of points to generate
r1 = runifpoint(N) #Generate N uniform random points
par(mar=c(0,0,0,0)) # set plot margin
plot(r1,pch="+",main="65 points under CSR")
# 3.2 Testing CSR using nearest neighbor distances and Monte Carlo simulation
## upper and lower bound
r1.ghat=Gest(r1)
r1.ghat$rs
par(mfrow=c(1,2))
plot(r1.ghat)
hold = matrix(0, nrow=100, ncol=length(r1.ghat$r))
dim(hold)
for (i in 1:100) {
rp =runifpoint(65)
rp.ghat = Gest(rp, r1.ghat$r)
rp.ghat.rs = rp.ghat$rs
hold[i,] = rp.ghat.rs
}
r1.ghat$r[100] #the 100th distance point
summary(hold[,100]) #summary of Ghat at the 100th distance point
max(hold[,100]) #upper bound of 100 simulations at the 100th point
min(hold[,100]) #lower bound of 100 simulations at the 100th point
apply(hold,2,max)[100]
ubnd = apply(hold,2,max)
lbnd = apply(hold,2,min)
## plot Ghat
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
par(mar=c(4,4.5,1.5,.5))
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
lines(r1.ghat$r,ubnd,lty=2,col=2)
lines(r1.ghat$r,lbnd,lty=2,col=2)
dev.copy(jpeg,"Gplot.jpg",width=5,height=5,units="in",res=300)
dev.off()
# 3. Hypothesis testing of spatial point patterns
# 3.1 Simulating CSR
?runifpoint
N = 65 # number of points to generate
r1 = runifpoint(N) #Generate N uniform random points
par(mar=c(0,0,0,0)) # set plot margin
plot(r1,pch="+",main="65 points under CSR")
# 3.2 Testing CSR using nearest neighbor distances and Monte Carlo simulation
## upper and lower bound
r1.ghat=Gest(r1)
r1.ghat$rs
par(mfrow=c(1,2))
plot(r1.ghat)
hold = matrix(0, nrow=100, ncol=length(r1.ghat$r))
dim(hold)
for (i in 1:100) {
rp =runifpoint(65)
rp.ghat = Gest(rp, r1.ghat$r)
rp.ghat.rs = rp.ghat$rs
hold[i,] = rp.ghat.rs
}
r1.ghat$r[100] #the 100th distance point
summary(hold[,100]) #summary of Ghat at the 100th distance point
max(hold[,100]) #upper bound of 100 simulations at the 100th point
min(hold[,100]) #lower bound of 100 simulations at the 100th point
apply(hold,2,max)[100]
ubnd = apply(hold,2,max)
lbnd = apply(hold,2,min)
## plot Ghat
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
par(mar=c(4,4.5,1.5,.5))
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
lines(r1.ghat$r,ubnd,lty=2,col=2)
lines(r1.ghat$r,lbnd,lty=2,col=2)
dev.copy(jpeg,"Gplot.jpg",width=5,height=5,units="in",res=300)
dev.off()
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
par(mar=c(4,4.5,1.5,.5))
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
lines(r1.ghat$r,ubnd,lty=2,col=2)
lines(r1.ghat$r,lbnd,lty=2,col=2)
plot(jp.ghat,rs~r,xlim=c(0,max(r1.ghat$r)))
ghat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Gest(runifpoint(n, win=win), r=r)$rs
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.ghat = Gest(jp)
jp.win = window(jp)
plot(jp.ghat, rs~r, main="G estimates")
jp.genv = ghat.env(n=jp$n, s=100, r=jp.ghat$r, win=jp.win)
lines(jp.ghat$r, jp.genv$Up, lty=5, col=2)
lines(jp.ghat$r, jp.genv$Down, lty=5, col=3)
fhat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Fest(runifpoint(n, win=win), r=r)$rs
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.fhat = Fest(jp)
jp.win = window(jp)
jp.fenv = fhat.env(n=jp$n, s=100, r=jp.fhat$r, jp.win)
plot(jp.fhat,rs~r, main="F estimates")
lines(jp.fhat$r, jp.fenv$Up, lty=5, col=2)
lines(jp.fhat$r, jp.fenv$Down, lty=5, col=3)
khat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Kest(runifpoint(n, win=win), r=r)$rs
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.khat = Kest(jp)
jp.win = window(jp)
jp.kenv = khat.env(n=jp$n, s=100, r=jp.khat$r, jp.win)
plot(jp.khat,rs~r, main="K function for JP")
lines(jp.khat$r, jp.kenv$Up, lty=5, col=2)
lines(jp.khat$r, jp.kenv$Down, lty=5, col=3)
jp.khat = Kest(jp)
library(spatstat)
?spatstat
rm(list=ls())
# 2. Exploratory analysis of spatial point patterns
data(japanesepines)
jp = japanesepines
khat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Kest(runifpoint(n, win=win), r=r)$rs
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.khat = Kest(jp)
jp.win = window(jp)
jp.kenv = khat.env(n=jp$n, s=100, r=jp.khat$r, jp.win)
plot(jp.khat,rs~r, main="K function for JP")
lines(jp.khat$r, jp.kenv$Up, lty=5, col=2)
lines(jp.khat$r, jp.kenv$Down, lty=5, col=3)
jp.kenv = khat.env(n=jp$n, s=100, r=jp.khat$r, jp.win)
khat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Kest(runifpoint(n, win=win), r=r)$border
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.khat = Kest(jp)
jp.win = window(jp)
jp.kenv = khat.env(n=jp$n, s=100, r=jp.khat$r, jp.win)
plot(jp.khat,rs~r, main="K function for JP")
lines(jp.khat$r, jp.kenv$Up, lty=5, col=2)
lines(jp.khat$r, jp.kenv$Down, lty=5, col=3)
khat.env = function(n, s, r, win=owin(c(0,1),c(0,1)))
{
hold = matrix(0, s, length(r))
for(i in 1:s)
{
hold[i,] = Kest(runifpoint(n, win=win), r=r)$border
}
mn = apply(hold, 2, mean)
Up = apply(hold, 2, max)
Down = apply(hold, 2, min)
return(data.frame(mn, Up, Down))
}
jp.khat = Kest(jp)
jp.win = window(jp)
jp.kenv = khat.env(n=jp$n, s=100, r=jp.khat$r, jp.win)
plot(jp.khat, border~r, main="K function for JP")
lines(jp.khat$r, jp.kenv$Up, lty=5, col=2)
lines(jp.khat$r, jp.kenv$Down, lty=5, col=3)
data(redwood) #load the dataset
?redwood
summary(redwood)
data(redwood) #load the dataset
?redwood
summary(redwood)
regular = rsyst(nx=10) #generate regular pattern
summary(regular)
rw = redwood
?density.ppp
rw.Z.05 = density.ppp(rw, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.05"))
plot(rw.Z.05, main = tl.05)
plot(rw.Z.05, main="Kernel Estimation of RW: sigma = 0.05")
points(rw, pch="+", col="6")
rw.Z.1 = density.ppp(rw, 0.1)
tl.1 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.1"))
plot(rw.Z.1, main=tl.1)
points(rw, pch="+", col="6")
rw.Z.1 = density.ppp(rw, 0.1)
tl.1 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.1"))
plot(rw.Z.1, main=tl.1)
points(rw, pch="+", col="6")
tl.05 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.05"))
plot(rw.Z.05, main = tl.05)
plot(rw.Z.05, main="Kernel Estimation of RW: sigma = 0.05")
points(rw, pch="+", col="6")
rw.Z.1 = density.ppp(rw, 0.1)
tl.1 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.1"))
plot(rw.Z.1, main=tl.1)
plot(rw.Z.1, main="Kernel Estimation of RW: sigma = 0.1")
points(rw, pch="+", col="6")
jp.Z.1 = density.ppp(jp, 0.1)
tl.1 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.1"))
plot(jp.Z.1, main=tl.1)
plot(jp.Z.1, main="Kernel Estimation of JP: sigma = 0.1")
points(jp, pch="+", col="6")
?density.ppp
jp.Z.05 = density.ppp(jp, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of JP: ", sigma, " = 0.05"))
plot(jp.Z.05, main = tl.05)
plot(jp.Z.05, main="Kernel Estimation of JP: sigma = 0.05")
points(jp, pch="+", col="6")
?density.ppp
rw.Z.05 = density.ppp(rw, 0.05)
par(mar=c(0,0,1,1)) # set plot margin
tl.05 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.05"))
plot(rw.Z.05, main = tl.05)
plot(rw.Z.05, main="Kernel Estimation of RW: sigma = 0.05")
points(rw, pch="+", col="6")
rw.Z.1 = density.ppp(rw, 0.1)
tl.1 = expression(paste("Kernel Estimation of RW: ", sigma, " = 0.1"))
plot(rw.Z.1, main=tl.1)
plot(rw.Z.1, main="Kernel Estimation of RW: sigma = 0.1")
points(rw, pch="+", col="6")
